<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { TypeName = "String", CompatibleName = "string" },
        new { TypeName = "SByte",  CompatibleName = "sbyte" },
        new { TypeName = "Byte",   CompatibleName = "byte" },
        new { TypeName = "Int16",  CompatibleName = "short" },
        new { TypeName = "UInt16", CompatibleName = "ushort" },
        new { TypeName = "Int32",  CompatibleName = "int" },
        new { TypeName = "UInt32", CompatibleName = "uint" },
        new { TypeName = "Int64",  CompatibleName = "long" },
        new { TypeName = "UInt64", CompatibleName = "ulong" },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
using System;
using System.Collections.Generic;



namespace FastEnumUtility.Internals
{
    /// <summary>
    /// Provides <see cref="IEnumerable{T}"/> extension methods.
    /// </summary>
    internal static partial class EnumerableExtensions
    {
        #region FrozenDictionary
        /// <summary>
        /// Converts to <see cref="FrozenDictionary{TKey, TValue}"/>.
        /// </summary>
        /// <typeparam name="TKey"></typeparam>
        /// <typeparam name="TValue"></typeparam>
        /// <param name="source"></param>
        /// <param name="keySelector"></param>
        /// <returns></returns>
        public static FrozenDictionary<TKey, TValue> ToFrozenDictionary<TKey, TValue>(this IEnumerable<TValue> source, Func<TValue, TKey> keySelector)
            => FrozenDictionary<TKey, TValue>.Create(source, keySelector);


        /// <summary>
        /// Converts to <see cref="FrozenDictionary{TKey, TValue}"/>.
        /// </summary>
        /// <typeparam name="TSource"></typeparam>
        /// <typeparam name="TKey"></typeparam>
        /// <typeparam name="TValue"></typeparam>
        /// <param name="source"></param>
        /// <param name="keySelector"></param>
        /// <param name="valueSelector"></param>
        /// <returns></returns>
        public static FrozenDictionary<TKey, TValue> ToFrozenDictionary<TSource, TKey, TValue>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> valueSelector)
            => FrozenDictionary<TKey, TValue>.Create(source, keySelector, valueSelector);
        #endregion
<# foreach (var x in parameters) { #>


        #region <#= x.TypeName #> Specialized FrozenDictionary
        /// <summary>
        /// Converts to <see cref="Frozen<#= x.TypeName #>KeyDictionary{TValue}"/>.
        /// </summary>
        /// <typeparam name="TValue"></typeparam>
        /// <param name="source"></param>
        /// <param name="keySelector"></param>
        /// <returns></returns>
        public static Frozen<#= x.TypeName #>KeyDictionary<TValue> ToFrozen<#= x.TypeName #>KeyDictionary<TValue>(this IEnumerable<TValue> source, Func<TValue, <#= x.CompatibleName #>> keySelector)
            => Frozen<#= x.TypeName #>KeyDictionary<TValue>.Create(source, keySelector);


        /// <summary>
        /// Converts to <see cref="Frozen<#= x.TypeName #>KeyDictionary{TValue}"/>.
        /// </summary>
        /// <typeparam name="TSource"></typeparam>
        /// <typeparam name="TValue"></typeparam>
        /// <param name="source"></param>
        /// <param name="keySelector"></param>
        /// <param name="valueSelector"></param>
        /// <returns></returns>
        public static Frozen<#= x.TypeName #>KeyDictionary<TValue> ToFrozen<#= x.TypeName #>KeyDictionary<TSource, TValue>(this IEnumerable<TSource> source, Func<TSource, <#= x.CompatibleName #>> keySelector, Func<TSource, TValue> valueSelector)
            => Frozen<#= x.TypeName #>KeyDictionary<TValue>.Create(source, keySelector, valueSelector);
        #endregion
<# } #>
    }
}
