<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var parameters = new[]
    {
        new { TypeName = "SByte",  CompatibleName = "sbyte",  },
        new { TypeName = "Byte",   CompatibleName = "byte",   },
        new { TypeName = "Int16",  CompatibleName = "short",  },
        new { TypeName = "UInt16", CompatibleName = "ushort", },
        new { TypeName = "Int32",  CompatibleName = "int",    },
        new { TypeName = "UInt32", CompatibleName = "uint",   },
        new { TypeName = "Int64",  CompatibleName = "long",   },
        new { TypeName = "UInt64", CompatibleName = "ulong",  },
    };
#>
// <auto-generated>
// This .cs file is generated by T4 template. Don't change it. Change the .tt file instead.
// </auto-generated>
#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace FastEnumUtility.Internals;



internal static class UnderlyingOperation<T>
    where T : struct, Enum
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string? GetName(T value)
    {
        switch (EnumInfo<T>.s_typeCode)
        {
<# foreach (var x in parameters) { #>
            case TypeCode.<#= x.TypeName #>:
                return <#= x.TypeName #>Operation.GetName(value);
<# } #>
            default:
                ThrowHelper.ThrowUnexpectedCodeReached();
                return null;
        }
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined(T value)
    {
        return EnumInfo<T>.s_typeCode switch
        {
<# foreach (var x in parameters) { #>
            TypeCode.<#= x.TypeName #> => <#= x.TypeName #>Operation.IsDefined(value),
<# } #>
            _ => false,
        };
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToString(T value)
    {
        switch (EnumInfo<T>.s_typeCode)
        {
<# foreach (var x in parameters) { #>
            case TypeCode.<#= x.TypeName #>:
                return <#= x.TypeName #>Operation.ToString(value);
<# } #>
            default:
                ThrowHelper.ThrowUnexpectedCodeReached();
                return null!;
        }
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryParseValue(ReadOnlySpan<char> text, out T result)
    {
        switch (EnumInfo<T>.s_typeCode)
        {
<# foreach (var x in parameters) { #>
            case TypeCode.<#= x.TypeName #>:
                return <#= x.TypeName #>Operation.TryParseValue(text, out result);
<# } #>
            default:
                result = default;
                return false;
        }
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryParseValue(ReadOnlySpan<byte> text, out T result)
    {
        switch (EnumInfo<T>.s_typeCode)
        {
<# foreach (var x in parameters) { #>
            case TypeCode.<#= x.TypeName #>:
                return <#= x.TypeName #>Operation.TryParseValue(text, out result);
<# } #>
            default:
                result = default;
                return false;
        }
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryGetMember(T value, [NotNullWhen(true)] out Member<T>? result)
    {
        switch (EnumInfo<T>.s_typeCode)
        {
<# foreach (var x in parameters) { #>
            case TypeCode.<#= x.TypeName #>:
                return <#= x.TypeName #>Operation.TryGetMember(value, out result);
<# } #>
            default:
                result = default;
                return false;
        }
    }


    #region Nested Types
<# foreach (var x in parameters) { #>
    private static class <#= x.TypeName #>Operation
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string? GetName(T value)
            => TryGetMember(value, out var member) ? member.Name : null;


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsDefined(T value)
        {
            if (EnumInfo<T>.s_isContinuous)
            {
                var min = toNumber(EnumInfo<T>.s_minValue);
                var max = toNumber(EnumInfo<T>.s_maxValue);
                var val = toNumber(value);
                return (min <= val) && (val <= max);
            }
            else
            {
                return EnumInfo<T>.s_memberByValue.ContainsKey(value);
            }


            #region Local Functions
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static <#= x.CompatibleName #> toNumber(T value)
            {
                ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
                return x;
            }
            #endregion
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string ToString(T value)
        {
            if (TryGetMember(value, out var member))
            {
                return member.Name;
            }
            else
            {
                ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
                return x.ToString(null, CultureInfo.InvariantCulture);
            }
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParseValue(ReadOnlySpan<char> text, out T result)
        {
            Unsafe.SkipInit(out result);
            ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref result);
            return <#= x.CompatibleName #>.TryParse(text, CultureInfo.InvariantCulture, out x);
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParseValue(ReadOnlySpan<byte> text, out T result)
        {
            Unsafe.SkipInit(out result);
            ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref result);
#if NET8_0_OR_GREATER
            return <#= x.CompatibleName #>.TryParse(text, CultureInfo.InvariantCulture, out x);
#else
            return <#= x.CompatibleName #>.TryParse(text, out x);
#endif
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryGetMember(T value, [NotNullWhen(true)] out Member<T>? result)
        {
            if (EnumInfo<T>.s_isContinuous)
            {
                var val = toNumber(value);
                var min = toNumber(EnumInfo<T>.s_minValue);
                var index = (int)(val - min);
                var members = EnumInfo<T>.s_orderedMembers;
                if ((uint)index < (uint)members.Length)
                {
                    result = members.At(index);
                    return true;
                }
                else
                {
                    result = null;
                    return false;
                }
            }
            else
            {
                return EnumInfo<T>.s_memberByValue.TryGetValue(value, out result);
            }


            #region Local Functions
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static <#= x.CompatibleName #> toNumber(T value)
            {
                ref var x = ref Unsafe.As<T, <#= x.CompatibleName #>>(ref value);
                return x;
            }
            #endregion
        }
    }



<# } #>
    #endregion
}
